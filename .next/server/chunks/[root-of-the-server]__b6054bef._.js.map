{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/lib/db.ts"],"sourcesContent":["// lib/db.ts - Prisma client singleton\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ||\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\"] : [],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n\r\nexport default prisma;\r\n"],"names":[],"mappings":"AAAA,sCAAsC;;;;;;;AACtC;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;KAAQ,GAAG;AAC5D;AAEF,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/lib/razorpay-utils.ts"],"sourcesContent":["// lib/razorpay-utils.ts - Razorpay payment utilities\r\nimport crypto from \"crypto\";\r\n\r\nconst RAZORPAY_KEY_ID = process.env.RAZORPAY_KEY_ID || \"\";\r\nconst RAZORPAY_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET || \"\";\r\n\r\n/**\r\n * Generate unique receipt ID\r\n */\r\nexport function generateReceiptId(): string {\r\n  return `aerocity-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create Razorpay order\r\n */\r\nexport async function createRazorpayOrder(\r\n  amount: number,\r\n  receipt?: string,\r\n): Promise<{\r\n  id: string;\r\n  entity: string;\r\n  amount: number;\r\n  amount_paid: number;\r\n  amount_due: number;\r\n  currency: string;\r\n  receipt: string;\r\n  offer_id: string | null;\r\n  status: string;\r\n  attempts: number;\r\n  notes: Record<string, any>;\r\n  created_at: number;\r\n}> {\r\n  try {\r\n    const RazorpayAPI = await import(\"razorpay\");\r\n    const razorpay = new RazorpayAPI.default({\r\n      key_id: RAZORPAY_KEY_ID,\r\n      key_secret: RAZORPAY_KEY_SECRET,\r\n    });\r\n\r\n    // Amount in paise (multiply by 100)\r\n    const response = await razorpay.orders.create({\r\n      amount: Math.round(amount * 100),\r\n      currency: \"INR\",\r\n      receipt: receipt || generateReceiptId(),\r\n      payment_capture: true,\r\n    });\r\n\r\n    return response;\r\n  } catch (error) {\r\n    console.error(\"Failed to create Razorpay order:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Verify Razorpay payment signature\r\n */\r\nexport async function verifyRazorpaySignature(\r\n  orderId: string,\r\n  paymentId: string,\r\n  signature: string,\r\n): Promise<boolean> {\r\n  try {\r\n    const data = `${orderId}|${paymentId}`;\r\n    const generated_signature = crypto\r\n      .createHmac(\"sha256\", RAZORPAY_KEY_SECRET)\r\n      .update(data)\r\n      .digest(\"hex\");\r\n\r\n    return generated_signature === signature;\r\n  } catch (error) {\r\n    console.error(\"Failed to verify Razorpay signature:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get payment details from Razorpay\r\n */\r\nexport async function getPaymentDetails(paymentId: string): Promise<any> {\r\n  try {\r\n    const RazorpayAPI = await import(\"razorpay\");\r\n    const razorpay = new RazorpayAPI.default({\r\n      key_id: RAZORPAY_KEY_ID,\r\n      key_secret: RAZORPAY_KEY_SECRET,\r\n    });\r\n\r\n    const payment = await razorpay.payments.fetch(paymentId);\r\n    return payment;\r\n  } catch (error) {\r\n    console.error(\"Failed to fetch payment details:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Refund payment\r\n */\r\nexport async function refundPayment(\r\n  paymentId: string,\r\n  amount?: number,\r\n): Promise<any> {\r\n  try {\r\n    const RazorpayAPI = await import(\"razorpay\");\r\n    const razorpay = new RazorpayAPI.default({\r\n      key_id: RAZORPAY_KEY_ID,\r\n      key_secret: RAZORPAY_KEY_SECRET,\r\n    });\r\n\r\n    const refundData: any = {\r\n      payment_id: paymentId,\r\n    };\r\n\r\n    if (amount) {\r\n      refundData.amount = Math.round(amount * 100); // Convert to paise\r\n    }\r\n\r\n    const refund = await razorpay.payments.refund(paymentId, refundData);\r\n    return refund;\r\n  } catch (error) {\r\n    console.error(\"Failed to refund payment:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate Razorpay credentials\r\n */\r\nexport function validateRazorpayCredentials(): boolean {\r\n  return !!(RAZORPAY_KEY_ID && RAZORPAY_KEY_SECRET);\r\n}\r\n"],"names":[],"mappings":"AAAA,qDAAqD;;;;;;;;;;;;;;;AACrD;;AAEA,MAAM,kBAAkB,QAAQ,GAAG,CAAC,eAAe,IAAI;AACvD,MAAM,sBAAsB,QAAQ,GAAG,CAAC,mBAAmB,IAAI;AAKxD,SAAS;IACd,OAAO,CAAC,SAAS,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;AAC/E;AAKO,eAAe,oBACpB,MAAc,EACd,OAAgB;IAehB,IAAI;QACF,MAAM,cAAc;QACpB,MAAM,WAAW,IAAI,YAAY,OAAO,CAAC;YACvC,QAAQ;YACR,YAAY;QACd;QAEA,oCAAoC;QACpC,MAAM,WAAW,MAAM,SAAS,MAAM,CAAC,MAAM,CAAC;YAC5C,QAAQ,KAAK,KAAK,CAAC,SAAS;YAC5B,UAAU;YACV,SAAS,WAAW;YACpB,iBAAiB;QACnB;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oCAAoC;QAClD,MAAM;IACR;AACF;AAKO,eAAe,wBACpB,OAAe,EACf,SAAiB,EACjB,SAAiB;IAEjB,IAAI;QACF,MAAM,OAAO,GAAG,QAAQ,CAAC,EAAE,WAAW;QACtC,MAAM,sBAAsB,gHAAM,CAC/B,UAAU,CAAC,UAAU,qBACrB,MAAM,CAAC,MACP,MAAM,CAAC;QAEV,OAAO,wBAAwB;IACjC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO;IACT;AACF;AAKO,eAAe,kBAAkB,SAAiB;IACvD,IAAI;QACF,MAAM,cAAc;QACpB,MAAM,WAAW,IAAI,YAAY,OAAO,CAAC;YACvC,QAAQ;YACR,YAAY;QACd;QAEA,MAAM,UAAU,MAAM,SAAS,QAAQ,CAAC,KAAK,CAAC;QAC9C,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oCAAoC;QAClD,MAAM;IACR;AACF;AAKO,eAAe,cACpB,SAAiB,EACjB,MAAe;IAEf,IAAI;QACF,MAAM,cAAc;QACpB,MAAM,WAAW,IAAI,YAAY,OAAO,CAAC;YACvC,QAAQ;YACR,YAAY;QACd;QAEA,MAAM,aAAkB;YACtB,YAAY;QACd;QAEA,IAAI,QAAQ;YACV,WAAW,MAAM,GAAG,KAAK,KAAK,CAAC,SAAS,MAAM,mBAAmB;QACnE;QAEA,MAAM,SAAS,MAAM,SAAS,QAAQ,CAAC,MAAM,CAAC,WAAW;QACzD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,MAAM;IACR;AACF;AAKO,SAAS;IACd,OAAO,CAAC,CAAC,CAAC,mBAAmB,mBAAmB;AAClD","debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/lib/errors.ts"],"sourcesContent":["// lib/errors.ts - Custom error classes\r\n\r\nexport class ApiError extends Error {\r\n  constructor(\r\n    public message: string,\r\n    public status: number = 400,\r\n    public code?: string,\r\n  ) {\r\n    super(message);\r\n    this.name = \"ApiError\";\r\n  }\r\n}\r\n\r\nexport class ValidationError extends ApiError {\r\n  constructor(message: string, public field?: string) {\r\n    super(message, 400, \"VALIDATION_ERROR\");\r\n    this.name = \"ValidationError\";\r\n  }\r\n}\r\n\r\nexport class NotFoundError extends ApiError {\r\n  constructor(message: string) {\r\n    super(message, 404, \"NOT_FOUND\");\r\n    this.name = \"NotFoundError\";\r\n  }\r\n}\r\n\r\nexport class UnauthorizedError extends ApiError {\r\n  constructor(message: string = \"Unauthorized\") {\r\n    super(message, 401, \"UNAUTHORIZED\");\r\n    this.name = \"UnauthorizedError\";\r\n  }\r\n}\r\n\r\nexport class ForbiddenError extends ApiError {\r\n  constructor(message: string = \"Forbidden\") {\r\n    super(message, 403, \"FORBIDDEN\");\r\n    this.name = \"ForbiddenError\";\r\n  }\r\n}\r\n\r\nexport class ConflictError extends ApiError {\r\n  constructor(message: string) {\r\n    super(message, 409, \"CONFLICT\");\r\n    this.name = \"ConflictError\";\r\n  }\r\n}\r\n\r\nexport class InternalServerError extends ApiError {\r\n  constructor(message: string = \"Internal Server Error\") {\r\n    super(message, 500, \"INTERNAL_SERVER_ERROR\");\r\n    this.name = \"InternalServerError\";\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,uCAAuC;;;;;;;;;;;;;;;;;AAEhC,MAAM,iBAAiB;;;;IAC5B,YACE,AAAO,OAAe,EACtB,AAAO,SAAiB,GAAG,EAC3B,AAAO,IAAa,CACpB;QACA,KAAK,CAAC,eAJC,UAAA,cACA,SAAA,aACA,OAAA;QAGP,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,wBAAwB;;IACnC,YAAY,OAAe,EAAE,AAAO,KAAc,CAAE;QAClD,KAAK,CAAC,SAAS,KAAK,0BADc,QAAA;QAElC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,sBAAsB;IACjC,YAAY,OAAe,CAAE;QAC3B,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,0BAA0B;IACrC,YAAY,UAAkB,cAAc,CAAE;QAC5C,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,uBAAuB;IAClC,YAAY,UAAkB,WAAW,CAAE;QACzC,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,sBAAsB;IACjC,YAAY,OAAe,CAAE;QAC3B,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,4BAA4B;IACvC,YAAY,UAAkB,uBAAuB,CAAE;QACrD,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;IACd;AACF","debugId":null}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/lib/booking-service.ts"],"sourcesContent":["// lib/booking-service.ts - Booking business logic service\r\nimport { prisma } from \"@/lib/db\";\r\nimport { createRazorpayOrder, generateReceiptId } from \"@/lib/razorpay-utils\";\r\nimport { ValidationError, NotFoundError, ConflictError } from \"@/lib/errors\";\r\nimport Decimal from \"decimal.js\";\r\n\r\nexport interface BookingItemInput {\r\n  ticketId: number;\r\n  quantity: number;\r\n}\r\n\r\nexport interface CreateBookingInput {\r\n  visitDate: string; // YYYY-MM-DD format\r\n  items: BookingItemInput[];\r\n  customerName: string;\r\n  customerMobile: string;\r\n  customerEmail?: string;\r\n  agentId?: number;\r\n  bookedByRole?: \"CUSTOMER\" | \"AGENT\";\r\n}\r\n\r\n/**\r\n * Get active offers for a specific date\r\n */\r\nasync function getActiveOffersForDate(date: Date) {\r\n  return prisma.offer.findMany({\r\n    where: {\r\n      isActive: true,\r\n      startDate: { lte: date },\r\n      endDate: { gte: date },\r\n    },\r\n    include: {\r\n      offerPrices: true,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Calculate best price for a ticket based on active offers\r\n */\r\nfunction getBestPrice(\r\n  ticketId: number,\r\n  customerPrice: Decimal,\r\n  agentPrice: Decimal,\r\n  offers: Array<any>,\r\n  isAgent: boolean,\r\n): {\r\n  appliedPrice: Decimal;\r\n  isOfferApplied: boolean;\r\n  offerId?: number;\r\n} {\r\n  let bestPrice = isAgent ? agentPrice : customerPrice;\r\n  let isOfferApplied = false;\r\n  let offerId: number | undefined;\r\n\r\n  // Find the lowest price across all active offers\r\n  for (const offer of offers) {\r\n    for (const offerPrice of offer.offerPrices) {\r\n      if (offerPrice.ticketId === ticketId) {\r\n        if (offerPrice.offerPrice < bestPrice) {\r\n          bestPrice = offerPrice.offerPrice;\r\n          isOfferApplied = true;\r\n          offerId = offer.id;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    appliedPrice: bestPrice,\r\n    isOfferApplied,\r\n    offerId,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a new booking\r\n */\r\nexport async function createBooking(input: CreateBookingInput) {\r\n  // Parse visit date\r\n  const visitDate = new Date(input.visitDate);\r\n  if (isNaN(visitDate.getTime())) {\r\n    throw new ValidationError(\"Invalid visitDate format\", \"visitDate\");\r\n  }\r\n\r\n  // Get all tickets\r\n  const ticketIds = input.items.map((item) => item.ticketId);\r\n  const tickets = await prisma.ticket.findMany({\r\n    where: {\r\n      id: { in: ticketIds },\r\n      isActive: true,\r\n    },\r\n  });\r\n\r\n  if (tickets.length !== ticketIds.length) {\r\n    throw new NotFoundError(\"One or more tickets not found or inactive\");\r\n  }\r\n\r\n  // Check if agent exists (if bookedByRole is AGENT)\r\n  let agentId: number | null = null;\r\n  let isAgent = input.bookedByRole === \"AGENT\";\r\n\r\n  if (isAgent && input.agentId) {\r\n    const agent = await prisma.user.findUnique({\r\n      where: { id: input.agentId },\r\n    });\r\n    if (!agent) {\r\n      throw new NotFoundError(\"Agent not found\");\r\n    }\r\n    agentId = input.agentId;\r\n  }\r\n\r\n  // Get active offers for the visit date\r\n  const activeOffers = await getActiveOffersForDate(visitDate);\r\n\r\n  // Create booking items and calculate total\r\n  let totalAmount = new Decimal(0);\r\n  const bookingItemsData: any[] = [];\r\n\r\n  for (const item of input.items) {\r\n    const ticket = tickets.find((t: any) => t.id === item.ticketId);\r\n    if (!ticket) {\r\n      throw new NotFoundError(`Ticket ${item.ticketId} not found`);\r\n    }\r\n\r\n    const { appliedPrice, isOfferApplied, offerId } = getBestPrice(\r\n      item.ticketId,\r\n      ticket.customerPrice as any,\r\n      ticket.agentPrice as any,\r\n      activeOffers,\r\n      isAgent,\r\n    );\r\n\r\n    const itemTotal = appliedPrice.times(item.quantity);\r\n    totalAmount = totalAmount.plus(itemTotal);\r\n\r\n    bookingItemsData.push({\r\n      ticketId: item.ticketId,\r\n      quantity: item.quantity,\r\n      basePrice: isAgent ? ticket.agentPrice : ticket.customerPrice,\r\n      appliedPrice,\r\n      isOfferApplied,\r\n      totalPrice: itemTotal,\r\n    });\r\n  }\r\n\r\n  // Generate booking reference\r\n  const bookingReference = \"BK_\" + Date.now() + \"_\" + Math.random().toString(36).substr(2, 9);\r\n\r\n  // Create Razorpay order\r\n  let razorpayOrderId: string;\r\n  try {\r\n    const receiptId = generateReceiptId();\r\n    const order = await createRazorpayOrder(\r\n      parseFloat(totalAmount.toString()),\r\n      receiptId,\r\n    );\r\n    razorpayOrderId = order.id;\r\n  } catch (error) {\r\n    console.error(\"Failed to create Razorpay order:\", error);\r\n    throw new ValidationError(\"Failed to initiate payment. Please try again.\", \"payment\");\r\n  }\r\n\r\n  // Get the offer to use (if multiple, use the first one with lowest price)\r\n  let selectedOfferId: number | null = null;\r\n  for (const item of bookingItemsData) {\r\n    if (item.isOfferApplied) {\r\n      // Find the offer for this item\r\n      const offer = activeOffers.find((o: any) =>\r\n        o.offerPrices.some(\r\n          (op: any) =>\r\n            op.ticketId === item.ticketId && op.offerPrice === item.appliedPrice,\r\n        ),\r\n      );\r\n      if (offer) {\r\n        selectedOfferId = offer.id;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create booking in database\r\n  const booking = await prisma.booking.create({\r\n    data: {\r\n      bookingReference,\r\n      visitDate: visitDate,\r\n      bookedByRole: input.bookedByRole || \"CUSTOMER\",\n      agentId,\n      customerName: input.customerName,\n      customerMobile: input.customerMobile,\n      customerEmail: input.customerEmail?.trim() || \"\",\n      totalAmount,\n      offerId: selectedOfferId,\n      paymentStatus: \"PENDING\",\r\n      razorpayOrderId,\r\n      bookingItems: {\r\n        create: bookingItemsData,\r\n      },\r\n    },\r\n    include: {\r\n      bookingItems: {\r\n        include: {\r\n          ticket: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return {\r\n    id: booking.id,\r\n    bookingReference: booking.bookingReference,\r\n    visitDate: booking.visitDate,\r\n    items: booking.bookingItems.map((item: any) => ({\r\n      ticketId: item.ticketId,\r\n      ticketName: item.ticket.name,\r\n      quantity: item.quantity,\r\n      basePrice: item.basePrice,\r\n      appliedPrice: item.appliedPrice,\r\n      isOfferApplied: item.isOfferApplied,\r\n      totalPrice: item.totalPrice,\r\n    })),\r\n    totalAmount: booking.totalAmount,\r\n    paymentStatus: booking.paymentStatus,\r\n    razorpayOrderId: booking.razorpayOrderId,\r\n    createdAt: booking.createdAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Get booking by reference\r\n */\r\nexport async function getBookingByReference(reference: string) {\r\n  const booking = await prisma.booking.findUnique({\r\n    where: { bookingReference: reference },\r\n    include: {\r\n      bookingItems: {\r\n        include: {\r\n          ticket: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!booking) {\r\n    throw new NotFoundError(\"Booking not found\");\r\n  }\r\n\r\n  return {\r\n    id: booking.id,\r\n    bookingReference: booking.bookingReference,\r\n    visitDate: booking.visitDate,\r\n    bookedByRole: booking.bookedByRole,\r\n    agentId: booking.agentId,\r\n    customerName: booking.customerName,\r\n    customerMobile: booking.customerMobile,\r\n    customerEmail: booking.customerEmail,\r\n    totalAmount: booking.totalAmount,\r\n    items: booking.bookingItems.map((item: any) => ({\r\n      ticketId: item.ticketId,\r\n      ticketName: item.ticket.name,\r\n      quantity: item.quantity,\r\n      basePrice: item.basePrice,\r\n      appliedPrice: item.appliedPrice,\r\n      isOfferApplied: item.isOfferApplied,\r\n      totalPrice: item.totalPrice,\r\n    })),\r\n    paymentStatus: booking.paymentStatus,\r\n    razorpayOrderId: booking.razorpayOrderId,\r\n    razorpayPaymentId: booking.razorpayPaymentId,\r\n    isValidated: booking.isValidated,\r\n    createdAt: booking.createdAt,\r\n  };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/lib/responses.ts"],"sourcesContent":["// lib/responses.ts - Standardized API responses\r\n\r\nexport interface ApiResponseSuccess<T> {\r\n  success: boolean;\r\n  message: string;\r\n  data: T;\r\n}\r\n\r\nexport interface ApiResponseError {\r\n  success: boolean;\r\n  message: string;\r\n  error: string;\r\n  code?: string;\r\n}\r\n\r\nexport interface PaginatedResponse<T> {\r\n  success: boolean;\r\n  data: T[];\r\n  pagination: {\r\n    currentPage: number;\r\n    pageSize: number;\r\n    totalElements: number;\r\n    totalPages: number;\r\n    hasNext: boolean;\r\n    hasPrevious: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Create a success response\r\n */\r\nexport function createSuccessResponse<T>(\r\n  message: string,\r\n  data: T,\r\n): ApiResponseSuccess<T> {\r\n  return {\r\n    success: true,\r\n    message,\r\n    data,\r\n  };\r\n}\r\n\r\n/**\r\n * Create an error response\r\n */\r\nexport function createErrorResponse(\r\n  message: string,\r\n  error: string,\r\n  code?: string,\r\n): ApiResponseError {\r\n  return {\r\n    success: false,\r\n    message,\r\n    error,\r\n    code,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a paginated response\r\n */\r\nexport function createPaginatedResponse<T>(\r\n  message: string,\r\n  items: T[],\r\n  currentPage: number,\r\n  pageSize: number,\r\n  totalElements: number,\r\n): PaginatedResponse<T> & { message: string } {\r\n  const totalPages = Math.ceil(totalElements / pageSize);\r\n\r\n  return {\r\n    success: true,\r\n    message,\r\n    data: items,\r\n    pagination: {\r\n      currentPage,\r\n      pageSize,\r\n      totalElements,\r\n      totalPages,\r\n      hasNext: currentPage < totalPages,\r\n      hasPrevious: currentPage > 1,\r\n    },\r\n  } as any;\r\n}\r\n"],"names":[],"mappings":"AAAA,gDAAgD;;;;;;;;;AA+BzC,SAAS,sBACd,OAAe,EACf,IAAO;IAEP,OAAO;QACL,SAAS;QACT;QACA;IACF;AACF;AAKO,SAAS,oBACd,OAAe,EACf,KAAa,EACb,IAAa;IAEb,OAAO;QACL,SAAS;QACT;QACA;QACA;IACF;AACF;AAKO,SAAS,wBACd,OAAe,EACf,KAAU,EACV,WAAmB,EACnB,QAAgB,EAChB,aAAqB;IAErB,MAAM,aAAa,KAAK,IAAI,CAAC,gBAAgB;IAE7C,OAAO;QACL,SAAS;QACT;QACA,MAAM;QACN,YAAY;YACV;YACA;YACA;YACA;YACA,SAAS,cAAc;YACvB,aAAa,cAAc;QAC7B;IACF;AACF","debugId":null}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///D:/G/Aerocity/AEROCITY-FE/Aerocity/app/api/bookings/%5Breference%5D/route.ts"],"sourcesContent":["// app/api/bookings/[reference]/route.ts - Get booking by reference\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\nimport { getBookingByReference } from \"@/lib/booking-service\";\r\nimport { createSuccessResponse, createErrorResponse } from \"@/lib/responses\";\r\nimport { NotFoundError } from \"@/lib/errors\";\r\n\r\nexport async function GET(\n  request: NextRequest,\n  context: { params: Promise<{ reference: string }> },\n) {\n  try {\n    const { reference } = await context.params;\n    const booking = await getBookingByReference(reference);\n\r\n    return NextResponse.json(\r\n      createSuccessResponse(\"Booking retrieved successfully\", booking),\r\n      { status: 200 },\r\n    );\r\n  } catch (error: any) {\r\n    console.error(\"Get booking error:\", error);\r\n\r\n    if (error instanceof NotFoundError) {\r\n      return NextResponse.json(\r\n        createErrorResponse(\"Not found\", error.message, \"NOT_FOUND\"),\r\n        { status: 404 },\r\n      );\r\n    }\r\n\r\n    return NextResponse.json(\r\n      createErrorResponse(\"Failed to retrieve booking\", error.message),\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,mEAAmE;;;;;AACnE;AACA;AACA;AACA;;;;;AAEO,eAAe,IACpB,OAAoB,EACpB,OAAmD;IAEnD,IAAI;QACF,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,QAAQ,MAAM;QAC1C,MAAM,UAAU,MAAM,IAAA,oJAAqB,EAAC;QAE5C,OAAO,gRAAY,CAAC,IAAI,CACtB,IAAA,2IAAqB,EAAC,kCAAkC,UACxD;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,sBAAsB;QAEpC,IAAI,iBAAiB,gIAAa,EAAE;YAClC,OAAO,gRAAY,CAAC,IAAI,CACtB,IAAA,yIAAmB,EAAC,aAAa,MAAM,OAAO,EAAE,cAChD;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gRAAY,CAAC,IAAI,CACtB,IAAA,yIAAmB,EAAC,8BAA8B,MAAM,OAAO,GAC/D;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}